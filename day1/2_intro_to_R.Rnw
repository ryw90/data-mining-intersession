\documentclass{beamer}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}

\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}

\title{An introduction to R}
\author{Scott Powers and Ryan Wang}

\begin{document}
\SweaveOpts{concordance=TRUE}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Goal}
\begin{itemize}
  \item Serious data work requires programming (at least with the current state of tools like Excel and Tableau)
  \item In this tutorial, we'll work through the basics of R by analyzing the set of box scores from the '12-'13 NBA season
  \item Among other things, we will:
  \begin{enumerate}
    \item Identify the top scorers in that season
    \item Understand how statistics vary over the course of a season
    \item Determine the relationship between scoring and rebounding
    \item Build a model for predicting this year's top scorers
  \end{enumerate}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{The help function}
\begin{itemize}
  \item R is a very well-documented language
  \item A crucial function is help, as it allows you to access that documentation
  \item It can be accessed by help(function) or ?function for short e.g. type ?help to learn more about the help function
  \item Google is also a great resource and usually links to either \href{http://stackoverflow.com/questions/tagged/r}{stackoverflow} or \href{http://www.r-project.org/mail.html}{the R mailing list}
\end{itemize}
\end{frame}

%%%
%%%
\section{A look at the data}
%%%
%%%

\begin{frame}[fragile]{Data frames}
\begin{block}{Let's start by reading in some real-life data}
<<>>=
  setwd('~/GitHub/data-mining-intersession/day1')
  nba <- read.csv('box_2012to2013.csv', stringsAsFactors=F)
  class(nba)
@
\end{block}
In R terminology, data typically comes in the form of a \textit{data.frame} (try ?data.frame). Data frames are essentially matrices that can store non-numeric values, and very similar to spreadsheets.
\end{frame}

\begin{frame}[fragile]{Data frames cont.}
\begin{block}{This is essentially the same as what you would see if you opened the .csv file in MS Excel}
<<>>==
  nba[1:5,1:5]
@
\end{block}
Columns correspond to \textit{variables} e.g. column 5 indicates the number of minutes played. Rows correspond to \textit{observations} e.g. row 1 corresponds to Trevor Booker's line on the box score.
\end{frame}

\begin{frame}[fragile]{Data frames cont.}
\begin{block}{This data frame contains 31,375 rows (observations) and 19 columns (variables)}
<<>>==
nrow(nba)
ncol(nba)
dim(nba)
@
\end{block}
\end{frame}

%%%
%%%
\section{R Basics}
%%%
%%%

\begin{frame}[fragile]{Accessing elements of the data}
\begin{block}{Specific elements of the data can be accessed with [row, column] coordinates}
<<>>==
  nba[1:2,1:2]
  nba[1,1]
  nba[2,1]  
@
\end{block}
We'll discuss subsetting data frames more in-depth after we have seen how vectors (and specifically sequences) work.
\end{frame}

\begin{frame}[fragile]{Vectors}
\begin{block}{The fundamental unit of computation in R is the vector. Create a vector by combining values with the "c" function (see ?vector and ?c):}
<<>>==
  c(1,2,3,4,5)
  c('a','b','c','d','e')
@
\end{block}
\end{frame}

\begin{frame}[fragile]{Vectors cont.}
\begin{block}{Assign a value, which includes vectors, to a name using the "<-" operator (see ?assignOps)}
<<>>==
  v1 <- c(1,2,3,4,5)
  v1
  v1[1]
@
\end{block}
The first element of v1 is 1, and the second element is 2. Note that unlike most programming languages, indexing starts at 1.
\end{frame}

\begin{frame}[fragile]{Vectors cont.}
\begin{block}{Most functions involving vectors operate element-wise. Calling a function like ?sum or ?mean on a vector will collapse it:}
<<>>==
  v1 + 3
  v1 + v1 
  sqrt(v1)
  sum(v1^2)
@
\end{block}
\end{frame}

\begin{frame}[fragile]{Vectors cont.}
\begin{block}{The ":" operator (see ?colon) creates a sequence, which is also a vector}
<<>>==
  x <- 1:5
  x
  x[1]
@
\end{block}
\end{frame}

\begin{frame}[fragile]{Vectors cont.}
\begin{block}{Boolean values are TRUE and FALSE, or T and F for short (see ?logical)}
<<>>==
TRUE & FALSE
!(!T & F)
@
\end{block}
\begin{block}{It is easy to create boolean vectors by writing conditions. This will come in handy soon.}
<<>>==
1:5 > 2
@
\end{block}
\end{frame}

\begin{frame}{Exercises}
\begin{enumerate}
  \item Create a vector of the even numbers between 1 and 50
  \item What happens if you use ?sum on a vector of boolean values?
  \item What would happen if you typed nba[,]?
\end{enumerate}
\end{frame}

%%%
%%%
\section{Exploring the data}
%%%
%%%

\begin{frame}[fragile]{Accessing elements of the data cont.}
\begin{block}{Now that we know about sequences, see that the data frame is subsetted by passing a vector of row and/or column indices}
<<>>==
  nba[1:5,1:5] # rows 1 to 5, columns 1 to 5
@
<<eval=F>>==
  nba[1:5,] # would give rows 1 to 5, all columns
@
\end{block}
You can access all the entries along a particular dimension by leaving the slot blank.
\end{frame}

\begin{frame}[fragile]{Accessing elements of the data cont.}
\begin{block}{A neat feature of data frames is that columns are named. Access specific columns with the "\$" operator (see ?Extract)}
<<>>==
  names(nba)[1:5]
  nba$pid[1:5]
  nba[1:5, 'pid'] # alternatively...
@
\end{block}
\end{frame}

\begin{frame}[fragile]{Exploring the data}
\begin{block}{Using boolean vectors, we can subset the data to look at specific players' statistics}
<<>>==
  lbj <- nba[nba$player == "LeBron James",]
  basic <- c('player','min','pts','reb')
  lbj[1:5,basic]
@
\end{block}
Under the hood, the boolean vector is being translated into a vector of indices for the TRUE entries. This can be accomplished explicitly by using the ?which function on a boolean vector.
\end{frame}

\begin{frame}[fragile]{Exploring the data cont.}
\begin{block}{It's not enough to know only the dimensions of the data frame, which tell us the number of box scores. We might need to know things such as: how many players were active?}
<<>>==
  v1 <- c('a','a','b','d')
  unique(v1)
  length(unique(v1))
  length(unique(nba$pid)) # number of players active
@
\end{block}
The ?unique function returns the unique values that appear in the inputted vector. The ?length function returns its length.
\end{frame}

\begin{frame}[fragile]{Exercises!}
\begin{enumerate}
  \item Familiarize yourself with the nba dataset. What does it contain? (Try ?View to for a spreadsheet-like view)  
  \item Create a subset of the data that contains entries for all point guards (PG). What are its dimensions?
  \item How many total games were played in the '12-'13 season? (note: some questions don't require data)
  \item What is the average number of minutes played? Points scored? (Try ?mean)  
\end{enumerate}
\end{frame}

%%%
%%%
\section{Scoring statistics}
%%%
%%%

\begin{frame}[fragile]{Total points scored}
\begin{block}{We now have some basic tools for exploring and manipulating data. We can use them to answer question such as: how many points did LeBron James score in the '12-'13 season?}
<<>>==
  sum(lbj$pts)
  sum(nba$pts[nba$player=='LeBron James'])
@
\end{block}
Check this against ESPN's records \url{http://espn.go.com/nba/player/stats/_/id/1966/lebron-james}.
\end{frame}

\begin{frame}[fragile]{Points per game (PPG)}
\begin{block}{Let's try answering more substantive questions such as: Who had the highest PPG? First we need to remove games in which a player did not play.}
<<>>==
  nba <- nba[nba$min>0,]
@
\end{block}
\begin{block}{Next, we want to repeatedly do the following:}  
<<>>=
  pid <- 9  
  tmp <- nba[nba$pid==pid,]
  mean(tmp$pts)
@
\end{block}
Player 9 is Ray Allen. How would you check this?
\end{frame}

\begin{frame}[fragile]{Points per game (PPG) cont.}
\begin{block}{We could literally repeat the averaging process with a loop. But since this is so common in data work, R has fast functions for this type of thing.}
<<>>=
  ppg <- aggregate(x=nba$pts,
                   by=list(pid=nba$pid),
                   FUN=mean)
  max(ppg$x) # highest ppg is 28.6
@
\end{block}
What's going on here? The vector nba\$pts is first split into subsets according to nba\$pid. Then the ?mean function is being applied to each subset. This idea is known as split-apply-combine and is similar to map-reduce (which is a big buzzword in big data).
\end{frame}

\begin{frame}[fragile]{Points per game (PPG) cont.}
\begin{block}{We can identify this player by figuring out the index of the maximum value, and looking it up in nba.}
<<>>=
  idx <- which.max(ppg$x)
  pid <- ppg$pid[idx]
  pid
  nba$player[nba$pid==pid][1]
@
\end{block}
\end{frame}

\begin{frame}[fragile]{Points per game (PPG) cont.}
\begin{block}{What if we want to know the top 5 scorers? The top N scorers? Luckily there is a better way than manually looking everyone up... First, we'll create a new dataset that maps pid to player name.}
<<>>==
  plyrs <- unique(nba[,c('pid','player')])
  plyrs[1:5,]
@
\end{block}
This is a lookup table of sorts. We can always consult it to figure out the player name corresponding to a pid. Can we always do the reverse?
\end{frame}

\begin{frame}[fragile]{Points per game (PPG) cont.}
\begin{block}{Next, let's try merging two datasets. We'll combine our ppg dataset with the pid->player mapping so we don't have to lookup names separately anymore.}
<<>>==
  ppg <- merge(ppg, plyrs, by='pid')
  ppg[1:5,]
@
\end{block}
Think about how you would do this by hand. For each pid in \emph{ppg}, you'd look it up in \emph{plyrs} and find the associated player name. Then you'd come back to \emph{ppg} and record the name you found. This is also known as joining.
\end{frame}

\begin{frame}[fragile]{Points per game (PPG) cont.}
\begin{block}{The last thing to do is sort ppg. We'll use the ?order function to sort by ppg\$x.}
<<>>==
  order_ppg <- order(ppg$x, decreasing=T)
  order_ppg[1:5] # vector of indices
  ppg <- ppg[order_ppg,]
  ppg[1:5,]
@
\end{block}
\end{frame}

\begin{frame}{Exercises}
\begin{enumerate}
  \item Calculate rebounds, assists, and blocks per game (reb, ast, blk). Who are the top players in each category?
  \item Which team scored the most points per game?
\end{enumerate}
\end{frame}

%%%
%%%
\section{Visualizing data}
%%%
%%%

\begin{frame}[fragile]{Histograms}
\begin{block}{We know a bit about PPG for the top players. What does the distribution look like?}
\setkeys{Gin}{width=0.5\textwidth}
<<fig=T>>=
  hist(ppg$x)
@
\end{block}
\end{frame}

\begin{frame}[fragile]{PPG over the season}
\begin{block}{Another interesting question is how much does PPG vary over the course of the season? We'll plot the time series with ?plot.}
\setkeys{Gin}{width=0.35\textwidth}
<<fig=T>>=
  lbj <- subset(nba, player=='LeBron James')
  lbj_ppg <- cumsum(lbj$pts)/1:length(lbj$pts)
  plot(lbj_ppg, type='l')
@  
\end{block}
Time series are very common in applications within finance.
\end{frame}

\begin{frame}[fragile]{PPG over the season cont.}
\begin{block}{How did LeBron compare to Kevin Durant? We can overlay plots with the ?lines function}
\setkeys{Gin}{width=0.35\textwidth}
<<fig=T>>==
  kd <- subset(nba, player=='Kevin Durant')
  kd_ppg <- cumsum(kd$pts)/1:length(kd$pts)
  plot(lbj_ppg, type='l', ylim=c(20,30))
  lines(kd_ppg, type='l', col='red')
@
\end{block}
Note that we're sidestepping the fact that they might not have played the same number of games.
\end{frame}

\begin{frame}[fragile]{Relationship between scoring and rebounding}
\begin{block}{Let's switch gears a bit. We'll now consider the relationship between scoring and rebounding. First let's get all these stats in one place.}
\setkeys{Gin}{width=0.35\textwidth}
<<>>==
  stats <- c('min','reb','ast','stl','blk','tos','pts')
  pg <- aggregate(nba[,stats],list(pid=nba$pid),mean)
  pg <- merge(pg, plyrs, by='pid')
  pg[1:5,1:5]
@
\end{block}
\end{frame}

\begin{frame}[fragile]{Relationship between scoring and rebounding cont.}
\begin{block}{Next, let's look at a scatter plot of scoring (Y axis) versus rebounding (X axis). There seems to be a positive relationship}
\setkeys{Gin}{width=0.5\textwidth}
<<fig=T>>==
  plot(y=pg$pts, x=pg$reb)
@
\end{block}
\end{frame}

\begin{frame}{Exercises}
\begin{enumerate}
  \item Plot a histogram of rebounds per game. What does it tell you?
  \item How else can you describe distributions? (Try ?mean, ?sd, ?quantile).
  \item Plot the relationship between various stats. What is a drawback of per game stats? (Hint: Try against minutes played)
\end{enumerate}
\end{frame}

%%%
%%%
\section{Linear regression}
%%%
%%%

\begin{frame}[fragile]{Scoring and minutes}
\begin{block}{The point of Exercise 3 was that all of the per game statistics are highly dependent (and nearly linearly) on minutes played.}
\setkeys{Gin}{width=0.5\textwidth}
<<fig=T>>==
  plot(pg$pts~pg$min)
@
\end{block}
\end{frame}

\begin{frame}[fragile]{Scoring and minutes cont.}
\begin{block}{We can quantify the relationship between scoring and minutes using linear regression, implemented with the ?lm function (for linear model).}
<<>>==
  m1 <- with(pg, lm(pts~min))
  m1
@
\end{block}
Try summary(m1) for an assessment of how well the model fits the data. This is the type of thing you would learn about in an intro stats course.
\end{frame}

\begin{frame}[fragile]{Scoring and minutes cont.}
\begin{block}{The idea of linear regression is basically to fit a line through the scatter plot of Y on X.}
\setkeys{Gin}{width=0.5\textwidth}
<<fig=T>>==
  plot(pg$pts~pg$min)
  abline(m1, col='red')
@
\end{block}
\end{frame}

\begin{frame}[fragile]{Scoring and minutes cont.}
\begin{block}{How do we interpret this model?}
<<>>==
  m1
@
\end{block}
Since it's a line, the model is defined by two parameters - slope and intercept. The slope can be interpreted as follows: for the average player, each additional minute per game results in an additional 0.5 points per game.
\end{frame}

\begin{frame}[fragile]{Scoring and minutes cont.}
\begin{block}{Linear regression supplies us with a method for making predictions.}
<<>>==
  fake_player <- list(min=20.0)
  predict(m1, newdata=fake_player)
@
\end{block}
In particular, $\hat{pts} = 0.52*min - 2.60$ where $\hat{pts}$ is our prediction. So we would predict that a player who played 20 minutes per game would score 7.8 points per game. Admittedly, this is not a great model. But it's a start.
\end{frame}

\begin{frame}{Exercises}
\begin{enumerate}
  \item Extend the regression model by adding additional variables. (Hint: You will need formulas of the form lm(y~x1+x2+...))
  \item (challenge) Rank top scorers by points per 48 minute, as opposed to points per game. What additional considerations must you make?
  \item (challenge) Compare points per 48 minute to rebounds per 48 minute. Verify that the positive relationship between ppg and rpg is due almost entirely to minutes played.
  \item (challenge) Create a regression model for predicting  player's ppg from last year's ppg. Data from the '11-'12 season is also available on GitHub. How well does this model work for '13-'14?
\end{enumerate}
\end{frame}

\end{document}